<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>组合数学 | liuyl's blog</title><meta name=keywords content="ACM,数学"><meta name=description content="常用或不常用的组合数学概念与公式"><meta name=author content="liuyl"><link rel=canonical href=https://liuyilong.com/p/tech/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.521ab9c2c4949eead7bcee2b18b3fdaac0ab5200af213f1b75ece8f778f0f1e0.css integrity="sha256-Uhq5wsSUnurXvO4rGLP9qsCrUgCvIT8bdezo93jw8eA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://liuyilong.com/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://liuyilong.com/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://liuyilong.com/avatar.jpg><link rel=apple-touch-icon href=https://liuyilong.com/avatar.jpg><link rel=mask-icon href=https://liuyilong.com/avatar.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><style>.katex-display>.katex{white-space:normal}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="组合数学"><meta property="og:description" content="常用或不常用的组合数学概念与公式"><meta property="og:type" content="article"><meta property="og:url" content="https://liuyilong.com/p/tech/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"><meta property="og:image" content="https://liuyilong.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="p"><meta property="article:published_time" content="2023-03-27T23:02:34+08:00"><meta property="article:modified_time" content="2023-03-27T23:02:34+08:00"><meta property="og:site_name" content="liuyl's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://liuyilong.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="组合数学"><meta name=twitter:description content="常用或不常用的组合数学概念与公式"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"📖 文章","item":"https://liuyilong.com/p/"},{"@type":"ListItem","position":3,"name":"组合数学","item":"https://liuyilong.com/p/tech/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"组合数学","name":"组合数学","description":"常用或不常用的组合数学概念与公式","keywords":["ACM","数学"],"articleBody":"一.基本法则 1.加法法则 设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$或$B$”共有$m+n$种产生方式。\n加法法则注重于分类问题的解决。\n2.乘法法则 设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$与$B$”共有$m∗n$种产生方式。\n乘法法则注重于分步问题的解决。\n二.排列 1.不可重排列 从$n$个不同的元素中取出$r$个元素，按次序排列的方案数，称作从$n$个中取$r$个的无重排列，用$A(n,r)$表示。 $$ A_n^r=\\frac{n!}{(n-r)!} $$\n2.可重排列数 从$n$​个不同元素中取$r$​个元素，每个元素可以重复取，方案数为 $n^r$ ​，即每个位置有$n$​个选择，共$r$​个位置。\n3.圆排列 从$n$​个不同元素中取出$r$​个元素形成一个环，最终环的个数。方案数为: $$ \\frac{A(n,r)}{r}\\ \\ \\ \\ \\ \\ \\ \\ ,2\\leq r\\leq n $$ 即先考虑所有的排列情况并将其连接成环，一个环从中间断开会形成$r$个序列，那么所有的情况除以$r$则得到最终方案数。\n4.项链排列 从$n$个不同元素中取出$r$个元素形成一个圆项链，最终项链个数。\n类似于圆排列，但是项链可以翻转，正面向上和反面向上两种方式放置各个数是同一个排列，所以方案数为： $$ \\frac{A(n,r)}{2r}\\ \\ \\ \\ \\ \\ \\ \\ ,3\\leq r\\leq n $$\n5.多重集的排列 多重集的排列数也称为多重组合数，是有重$n$个元素的全排列，要区别于多重集的组合数，两者是完全不同的概念！\n设元素$a_1,a_2,⋯,a_k$​互不相同，每个元素有$n_i$​​个，$n_1+n_2+…+n_k=n$​，那么所有元素的全排列为： $$ \\frac{n!}{n_1!n_2!…n_k!} $$ 可记为 $\\tbinom{n}{n_1,n_2,…,n_k}$\n可以理解为：先将所有的元素打上标号，那么就全为不同的元素，此时方案数为$n!$，之后对于每一类元素消除其冗余度$n_i!$即可。\n带限制的排列问题可以用指数型母函数解决。\n三.组合 1.无重组合 从$n$​个不同元素中取出$r$个元素，不考虑元素之间的顺序时，总的方案数。记为$C(n,r)$或者$\\tbinom{n}{r}$​​​。 有公式： $$ C(n,r)=\\frac{n!}{r!(n-r)!} $$\n2.可重组合 从$n$个不同元素中取出$r$个数，每个元素可以重复取（相当于每种元素都有大于等于$r$个）的组合方案数。\n可以将问题等价于：把$r$个元素划分成$n$类，每类元素个数没有要求。\n那么方案数即为： $$ C(r+n−1,n−1) $$ 相当于求解$x_1+x_2+⋯+x_n=r$的非负整数解的方案数，采用隔板法即可求解。\n3.多重集的组合 设$S=$ { $n_1⋅a_1,n_2⋅a_2,…,n_k⋅a_k$ }表示由$n_1$个$a_1$, $n_2$个$a_2$ ,…，$n_k$个$a_k$组成的多重集。那么对于整数$r$，从$S$中选择$r$个元素组成一个多重集的方案数就是多重集的组合数。\n是可重组合的一般化，可重组合较为特殊的是每个元素是有无限个可以取。\n可用普通母函数解决。\n4.不相邻组合 从 $A=$ { $1,2,⋯,n$ } 中取 $r$ 个不相邻的组合方案数，其组合数为 $$ C(n-r+1,r) $$ 可采用标号法来求解，假设选取任意一个解 $S=$ { $1,3,⋯,n$ }。\n因为是组合，我们将其按照升序排列，对应位置的下标为 { $0,1,⋯,r−1$​ }。\n我们将元素与对应下标相减（去掉限制条件），那么有 $S^′=$ { $1,2,⋯,n−r+1$ }。易知问题转变成了从 $n−r+1$个数中选取 $r$ 个数的组合数。这两者的方案数是一一对应的。\n相同的方法可以用来求解可重组合数，只是我们要累加元素的下标（可以去掉重复），同样可以得到上述结果。\n5.基本公式 组合数为二项式定理展开式中对应项的系数： $$ (x+y)^n=\\sum_{i=0}^nC(n,i)x^iy^{n-i} $$ 相当于$(x+y)⋅(x+y)⋅⋯⋅(x+y)$ 中，每一项只会选取一个，那么若$x$选取了$i$个，对应$y$选取了$n−i$ 个，方案数为$C(n,i)=C(n,n−i)$。\n根据这个，令$x=y=1$则有：\n$$ \\sum_{i=0}^n C(n,i)=2^n $$ 令$x=1,y=−1$有：\n$$ \\sum_{i=0}^n(-1)^iC(n,i)=0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ , n\\neq0 $$ 还有些其它的式子：\n$$ C(n,m)=C(n−1,m−1)+C(n−1,m) $$ 考虑第$m$个元素选还是不选，分类过后加起来即可。\n$$ C(n,m)⋅C(m,r)=C(n,r)⋅C(n−r,m−r) $$ 另外，二项式定理还可以扩展为多项式定理：\n$$ (x_1+x_2+⋯+x_t)^n=\\sum_{n_1+⋯+n_t=n}\\tbinom {n}{n_1,n_2,⋯,n_t}{x_1}^{n_1}{x_2}^{n_2}…{x_t}^{n_t} $$ 原理是 $$ C(n,n_1)⋅C(n−n_1,n_2)⋅⋯⋅C(n−n_1−n_2−⋯−n_{t−1},n_t)=\\tbinom {n}{n_1,n_2,⋯,n_t} $$ 可见多项式的系数刚好对应多重集的排列个数。\n6.常用公式 求组合数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* ******************************************************** *方法1：C(n,m)=fact[n]/fact[m]/fact[n-m] *！！！最常用！！！\t******************************************************** */ // 快速幂求逆元计算组合数，需要mod是质数，否则用exgcd求逆元 ll C(ll n, ll m) { if (n \u003c m || m \u003c 0) return 0; return fact[n] * qmi(fact[m], mod-2) % mod * qmi(fact[n-m], mod-2) % mod; } ll lucas(ll n, ll m) // 模数mod小于等于n或m时需要用 { if (m == 0) return 1; return lucas(n/mod, m/mod) * C(n%mod, m %mod) % mod; } /* ******************************************************** *方法2：递推法 O(nm) ******************************************************** */ for (int i = 0; i \u003c= n; i++) for (int j = 0; j \u003c= i \u0026\u0026 j \u003c= m; j++) if (!j) f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; /* ******************************************************** *方法3：固定一维递推 ******************************************************** */ C(n, m) = C(n, m - 1) * (n - m + 1) / m; C(n, m) = C(n - 1, m) * n / (n - m); /* ******************************************************** *方法4：分解质因数求组合数 *比较适用于高精度, 也适用于模数 p 没有逆元的情况 *令N = max(n, m),时间复杂度为 O（N） ******************************************************** */ // 非高精度版本。n, m 是int范围, n \u003e= m \u003e= 0 ; int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } int C(int n, int m) { int ans = 1; for (int i = 1; i \u003c= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); ans = (ll)ans * qmi(p, s) % mod; } return ans; } // 高精度版： int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } vector\u003cint\u003e C(int n, int m) { vector\u003cint\u003e ans; ans.push_back(1); for (int i = 1; i \u003c= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); while (s--) ans = mul(ans, p); } return ans; } $$ C(n,m)=C(n,n-m) $$\n$$ C(n,m)=C(n−1,m−1)+C(n−1,m) $$\n$$ C(n, m) = \\frac{A(n, m)} { m!} $$\n$$ C(n, m) = C(n, m - 1) ⋅ \\frac{n - m + 1} {m} = C(n - 1, m) ⋅ \\frac{n} { n - m} $$\n$$ C(n,0)+C(n,1)+…+C(n,n)=\\sum_{i=0}^n C(n,i)=2^n $$\n$$ C(n,0)-C(n,1)+…+(-1)^nC(n,n)=\\sum_{i=0}^n(-1)^iC(n,i)=[n=0] $$\n范德蒙德卷积公式： $$ C_n^0C_m^k+C_n^1C_m^{k-1}+…+C_n^kC_m^0=\\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k $$ 从意义上理解即可，也就是从数量为 $n$ 和 $m$ 的两个堆中一共选择 $k$​​​ 个物品。\n$$ C_n^0C_m^0+C_n^1C_m^1+…+C_n^mC_m^m=\\sum_{i=0}^mC_n^iC_m^i=\\sum_{i=0}^mC_n^iC_m^{m-i}=C_{n+m}^m $$\n由7变换\n$$ (C_n^0)^2+(C_n^1)^2+…+(C_n^n)^2=\\sum_{i=0}^n(C_n^i)^2=C_{2n}^n $$ 由7变换\n$$ C_n^0C_n^1+C_n^1C_n^2+…+C_n^{n-1}C_n^n=\\sum_{i=1}^nC_n^{i-1}C_n^i=C_{2n}^{n-1} $$ 由7变换，令$m=n$，$k=n-1$​\n$$ kC_n^k=nC_{n-1}^{k-1} $$\n$$ 1C_n^1+2C_n^2+3C_n^3+…+nC_n^n=\\sum_{i=0}^niC_n^i=n2^{n-1} $$\n对多项式函数求导\n$$ 1^2C_n^1+2^2C_n^2+3^2C_n^3+…+n^2C_n^n=\\sum_{i=0}^ni^2C_n^i=n(n+1)2^{n-2} $$ 对多项式函数求导\n$$ 1(C_n^1)^2+2(C_n^2)^2+3(C_n^3)^2+…+n(C_n^n)^2=\\sum_{i=0}^ni(C_n^i)^2=nC_{2n-1}^{n-1} $$\n由11代换，9变形\n$$ C_l^k+C_{l+1}^k+…+C_r^k=C_{r+1}^{k+1}-C_l^{k+1} $$\n式子左侧加$C_l^{k+1}$​​再化简\n$$ C_n^0+C_{n-1}^1+C_{n-2}^2+…+C_0^n=\\sum_{i=0}^nC_{n-i}^i=F_{n+1},\\ \\ \\ \\ \\ F是斐波那契数列 $$\n$$ 令f(n,k)=C_n^0+C_n^1+…+C_n^k=\\sum_{i=0}^kC_n^i\\\\ 则有f(n,k)=2*f(n-1,k)-C_{n-1}^k $$\n错位相加即可得到：\n递推计算$f(0,k)$，$f(1,k)$,…,$f(n,k)$：\n1 2 3 f[0] = 1; for (int i = 1; i \u003c= n; i++) f[i] = (2ll * f[i - 1] % mod - C(i - 1, k)) % mod, (f[i] += mod) %= mod; 7.常用组合计数方法 递推法计数：\n长度为 $n$ 的 $01$ 序列, 每个位置可以任取 $0$ 或 $1$, 要求相邻两个 $1$ 之间隔着至少 $k$ 个 $0$ 求合法的序列数：\n设 $f(i)$ 为最后一个 $1$ 在 位置 $i$ 的所有合法序列数，\n则 $f(i) = f(0) + f(1) + f(2) + … + f(i - k - 1) \\ \\ \\ \\ \\ \\ (f(0) \\equiv 1)$\n隔板法\n增量法（化相等为不等）\n给定三个正整数 $N,L,R$，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量。\n对于长度为 $k$ 的合法序列： $$ L\\leq a_1\\leq a_2\\leq …\\leq a_k\\leq R $$ 映射到序列 $b_i=a_i+i-1$： $$ L\\leq b_1","wordCount":"6761","inLanguage":"zh","datePublished":"2023-03-27T23:02:34+08:00","dateModified":"2023-03-27T23:02:34+08:00","author":{"@type":"Person","name":"liuyl"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liuyilong.com/p/tech/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},"publisher":{"@type":"Organization","name":"liuyl's blog","logo":{"@type":"ImageObject","url":"https://liuyilong.com/avatar.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://liuyilong.com accesskey=h title="liuyl's blog (Alt + H)"><img src=https://liuyilong.com/avatar.jpg alt aria-label=logo height=35>liuyl's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://liuyilong.com/ title=主页><span>主页</span></a></li><li><a href=https://liuyilong.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://liuyilong.com/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://liuyilong.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://liuyilong.com>主页</a>&nbsp;»&nbsp;<a href=https://liuyilong.com/p/>📖 文章</a></div><h1 class=post-title>组合数学</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2023-03-27
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_2><span class="fa fa-file-word-o"></span>
<span>6761字
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_3><span class="fa fa-clock-o"></span>
<span>14分钟
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_4><span class="fa fa-user-o"></span>
<span>liuyl
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://liuyilong.com/tags/acm/ style=color:var(--secondary)!important>ACM</a>
&nbsp;<a href=https://liuyilong.com/tags/%E6%95%B0%E5%AD%A6/ style=color:var(--secondary)!important>数学</a></span></span></span></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e5%9f%ba%e6%9c%ac%e6%b3%95%e5%88%99 aria-label=一.基本法则>一.基本法则</a><ul><li><a href=#1%e5%8a%a0%e6%b3%95%e6%b3%95%e5%88%99 aria-label=1.加法法则>1.加法法则</a></li><li><a href=#2%e4%b9%98%e6%b3%95%e6%b3%95%e5%88%99 aria-label=2.乘法法则>2.乘法法则</a></li></ul></li><li><a href=#%e4%ba%8c%e6%8e%92%e5%88%97 aria-label=二.排列>二.排列</a><ul><li><a href=#1%e4%b8%8d%e5%8f%af%e9%87%8d%e6%8e%92%e5%88%97 aria-label=1.不可重排列>1.不可重排列</a></li><li><a href=#2%e5%8f%af%e9%87%8d%e6%8e%92%e5%88%97%e6%95%b0 aria-label=2.可重排列数>2.可重排列数</a></li><li><a href=#3%e5%9c%86%e6%8e%92%e5%88%97 aria-label=3.圆排列>3.圆排列</a></li><li><a href=#4%e9%a1%b9%e9%93%be%e6%8e%92%e5%88%97 aria-label=4.项链排列>4.项链排列</a></li><li><a href=#5%e5%a4%9a%e9%87%8d%e9%9b%86%e7%9a%84%e6%8e%92%e5%88%97 aria-label=5.多重集的排列>5.多重集的排列</a></li></ul></li><li><a href=#%e4%b8%89%e7%bb%84%e5%90%88 aria-label=三.组合>三.组合</a><ul><li><a href=#1%e6%97%a0%e9%87%8d%e7%bb%84%e5%90%88 aria-label=1.无重组合>1.无重组合</a></li><li><a href=#2%e5%8f%af%e9%87%8d%e7%bb%84%e5%90%88 aria-label=2.可重组合>2.可重组合</a></li><li><a href=#3%e5%a4%9a%e9%87%8d%e9%9b%86%e7%9a%84%e7%bb%84%e5%90%88 aria-label=3.多重集的组合>3.多重集的组合</a></li><li><a href=#4%e4%b8%8d%e7%9b%b8%e9%82%bb%e7%bb%84%e5%90%88 aria-label=4.不相邻组合>4.不相邻组合</a></li><li><a href=#5%e5%9f%ba%e6%9c%ac%e5%85%ac%e5%bc%8f aria-label=5.基本公式>5.基本公式</a></li><li><a href=#6%e5%b8%b8%e7%94%a8%e5%85%ac%e5%bc%8f aria-label=6.常用公式>6.常用公式</a></li><li><a href=#7%e5%b8%b8%e7%94%a8%e7%bb%84%e5%90%88%e8%ae%a1%e6%95%b0%e6%96%b9%e6%b3%95 aria-label=7.常用组合计数方法>7.常用组合计数方法</a></li></ul></li><li><a href=#%e5%9b%9b%e5%b8%b8%e8%a7%81%e5%ba%8f%e5%88%97%e5%8f%8a%e6%80%a7%e8%b4%a8 aria-label=四.常见序列及性质>四.常见序列及性质</a><ul><li><a href=#1%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97 aria-label=1.斐波那契数列>1.斐波那契数列</a></li><li><a href=#2%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0 aria-label=2.卡特兰数>2.卡特兰数</a></li><li><a href=#3%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0 aria-label=3.斯特林数>3.斯特林数</a><ul><li><a href=#31-%e7%ac%ac%e4%b8%80%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0 aria-label="3.1 第一类斯特林数">3.1 第一类斯特林数</a></li><li><a href=#32-%e7%ac%ac%e4%ba%8c%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0 aria-label="3.2 第二类斯特林数">3.2 第二类斯特林数</a><ul><li><a href=#%e9%80%92%e6%8e%a8%e5%bc%8f aria-label=递推式>递推式</a></li><li><a href=#%e9%80%9a%e9%a1%b9%e5%85%ac%e5%bc%8f aria-label=通项公式>通项公式</a></li></ul></li></ul></li></ul></li><li><a href=#%e4%ba%94%e7%bd%ae%e6%8d%a2%e7%be%a4 aria-label=五.置换群>五.置换群</a><ul><li><a href=#1burnside-%e5%bc%95%e7%90%86 aria-label="1.Burnside 引理">1.Burnside 引理</a></li><li><a href=#2polya-%e5%ae%9a%e7%90%86 aria-label="2.Polya 定理">2.Polya 定理</a><ul><li><a href=#21-%e6%97%8b%e8%bd%ac%e7%bd%ae%e6%8d%a2 aria-label="2.1 旋转置换">2.1 旋转置换</a></li><li><a href=#22-%e7%bf%bb%e8%bd%ac%e7%bd%ae%e6%8d%a2 aria-label="2.2 翻转置换">2.2 翻转置换</a></li><li><a href=#23-%e5%b0%8f%e7%bb%93%e8%ae%ba aria-label="2.3 小结论">2.3 小结论</a></li></ul></li></ul></li><li><a href=#%e5%85%ad%e7%94%9f%e6%88%90%e5%87%bd%e6%95%b0 aria-label=六.生成函数>六.生成函数</a><ul><li><a href=#1%e5%b8%b8%e7%94%a8%e6%97%a0%e7%a9%b7%e7%ba%a7%e6%95%b0 aria-label=1.常用无穷级数>1.常用无穷级数</a></li><li><a href=#2%e4%be%8b%e5%ad%90 aria-label=2.例子>2.例子</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=一基本法则>一.基本法则<a hidden class=anchor aria-hidden=true href=#一基本法则>#</a></h1><h2 id=1加法法则>1.加法法则<a hidden class=anchor aria-hidden=true href=#1加法法则>#</a></h2><p>设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$或$B$”共有$m+n$种产生方式。</p><p>加法法则注重于<strong>分类</strong>问题的解决。</p><h2 id=2乘法法则>2.乘法法则<a hidden class=anchor aria-hidden=true href=#2乘法法则>#</a></h2><p>设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$与$B$”共有$m∗n$种产生方式。</p><p>乘法法则注重于<strong>分步</strong>问题的解决。</p><h1 id=二排列>二.排列<a hidden class=anchor aria-hidden=true href=#二排列>#</a></h1><h2 id=1不可重排列>1.不可重排列<a hidden class=anchor aria-hidden=true href=#1不可重排列>#</a></h2><p>从$n$个不同的元素中取出$r$个元素，按次序排列的方案数，称作从$n$个中取$r$个的无重排列，用$A(n,r)$表示。
$$
A_n^r=\frac{n!}{(n-r)!}
$$</p><h2 id=2可重排列数>2.可重排列数<a hidden class=anchor aria-hidden=true href=#2可重排列数>#</a></h2><p>从$n$​个不同元素中取$r$​个元素，每个元素可以重复取，方案数为 $n^r$ ​，即每个位置有$n$​个选择，共$r$​个位置。</p><h2 id=3圆排列>3.圆排列<a hidden class=anchor aria-hidden=true href=#3圆排列>#</a></h2><p>从$n$​个不同元素中取出$r$​个元素形成一个环，最终环的个数。方案数为:
$$
\frac{A(n,r)}{r}\ \ \ \ \ \ \ \ ,2\leq r\leq n
$$
即先考虑所有的排列情况并将其连接成环，一个环从中间断开会形成$r$个序列，那么所有的情况除以$r$则得到最终方案数。</p><h2 id=4项链排列>4.项链排列<a hidden class=anchor aria-hidden=true href=#4项链排列>#</a></h2><p>从$n$个不同元素中取出$r$个元素形成一个圆项链，最终项链个数。</p><p>类似于圆排列，但是项链可以翻转，正面向上和反面向上两种方式放置各个数是同一个排列，所以方案数为：
$$
\frac{A(n,r)}{2r}\ \ \ \ \ \ \ \ ,3\leq r\leq n
$$</p><h2 id=5多重集的排列>5.多重集的排列<a hidden class=anchor aria-hidden=true href=#5多重集的排列>#</a></h2><p><strong>多重集的排列数</strong>也称为<strong>多重组合数</strong>，是有重$n$个元素的全排列，要区别于<strong>多重集的组合数</strong>，两者是完全不同的概念！</p><p>设元素$a_1,a_2,⋯,a_k$​互不相同，每个元素有$n_i$​​个，$n_1+n_2+&mldr;+n_k=n$​，那么所有元素的全排列为：
$$
\frac{n!}{n_1!n_2!&mldr;n_k!}
$$
可记为 $\tbinom{n}{n_1,n_2,&mldr;,n_k}$</p><p>可以理解为：先将所有的元素打上标号，那么就全为不同的元素，此时方案数为$n!$，之后对于每一类元素消除其冗余度$n_i!$即可。</p><p>带限制的排列问题可以用指数型母函数解决。</p><h1 id=三组合>三.组合<a hidden class=anchor aria-hidden=true href=#三组合>#</a></h1><h2 id=1无重组合>1.无重组合<a hidden class=anchor aria-hidden=true href=#1无重组合>#</a></h2><p>从$n$​个不同元素中取出$r$个元素，不考虑元素之间的顺序时，总的方案数。记为$C(n,r)$或者$\tbinom{n}{r}$​​​。
有公式：
$$
C(n,r)=\frac{n!}{r!(n-r)!}
$$</p><h2 id=2可重组合>2.可重组合<a hidden class=anchor aria-hidden=true href=#2可重组合>#</a></h2><p>从$n$个不同元素中取出$r$个数，每个元素可以重复取（相当于每种元素都有大于等于$r$个）的组合方案数。</p><p>可以将问题等价于：把$r$个元素划分成$n$类，每类元素个数没有要求。</p><p>那么方案数即为：
$$
C(r+n−1,n−1)
$$
相当于求解$x_1+x_2+⋯+x_n=r$的非负整数解的方案数，采用隔板法即可求解。</p><h2 id=3多重集的组合>3.多重集的组合<a hidden class=anchor aria-hidden=true href=#3多重集的组合>#</a></h2><p>设$S=$ { $n_1⋅a_1,n_2⋅a_2,&mldr;,n_k⋅a_k$ }表示由$n_1$个$a_1$, $n_2$个$a_2$ ,…，$n_k$个$a_k$组成的多重集。那么对于整数$r$，从$S$中选择$r$个元素组成一个多重集的方案数就是<strong>多重集的组合数</strong>。</p><p>是可重组合的一般化，可重组合较为特殊的是每个元素是有无限个可以取。</p><p>可用普通母函数解决。</p><h2 id=4不相邻组合>4.不相邻组合<a hidden class=anchor aria-hidden=true href=#4不相邻组合>#</a></h2><p>从 $A=$ { $1,2,⋯,n$ } 中取 $r$ 个不相邻的组合方案数，其组合数为
$$
C(n-r+1,r)
$$
可采用标号法来求解，假设选取任意一个解 $S=$ { $1,3,⋯,n$ }。</p><p>因为是组合，我们将其按照升序排列，对应位置的下标为 { $0,1,⋯,r−1$​ }。</p><p>我们将元素与对应下标相减（去掉限制条件），那么有 $S^′=$ { $1,2,⋯,n−r+1$ }。易知问题转变成了从 $n−r+1$个数中选取 $r$ 个数的组合数。这两者的方案数是一一对应的。</p><p>相同的方法可以用来求解可重组合数，只是我们要累加元素的下标（可以去掉重复），同样可以得到上述结果。</p><h2 id=5基本公式>5.基本公式<a hidden class=anchor aria-hidden=true href=#5基本公式>#</a></h2><p>组合数为二项式定理展开式中对应项的系数：
$$
(x+y)^n=\sum_{i=0}^nC(n,i)x^iy^{n-i}
$$
相当于$(x+y)⋅(x+y)⋅⋯⋅(x+y)$ 中，每一项只会选取一个，那么若$x$选取了$i$个，对应$y$选取了$n−i$ 个，方案数为$C(n,i)=C(n,n−i)$。</p><p>根据这个，令$x=y=1$则有：</p><ul><li>$$
\sum_{i=0}^n C(n,i)=2^n
$$</li></ul><p>令$x=1,y=−1$有：</p><ul><li>$$
\sum_{i=0}^n(-1)^iC(n,i)=0\ \ \ \ \ \ \ \ \ \ \ , n\neq0
$$</li></ul><p>还有些其它的式子：</p><ul><li>$$
C(n,m)=C(n−1,m−1)+C(n−1,m)
$$</li></ul><p>考虑第$m$个元素选还是不选，分类过后加起来即可。</p><ul><li>$$
C(n,m)⋅C(m,r)=C(n,r)⋅C(n−r,m−r)
$$</li></ul><p>另外，二项式定理还可以扩展为多项式定理：</p><p>$$
(x_1+x_2+⋯+x_t)^n=\sum_{n_1+⋯+n_t=n}\tbinom {n}{n_1,n_2,⋯,n_t}{x_1}^{n_1}{x_2}^{n_2}&mldr;{x_t}^{n_t}
$$
原理是
$$
C(n,n_1)⋅C(n−n_1,n_2)⋅⋯⋅C(n−n_1−n_2−⋯−n_{t−1},n_t)=\tbinom {n}{n_1,n_2,⋯,n_t}
$$
可见多项式的系数刚好对应多重集的排列个数。</p><h2 id=6常用公式>6.常用公式<a hidden class=anchor aria-hidden=true href=#6常用公式>#</a></h2><ol start=0><li><p><strong>求组合数</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm> *方法1：C(n,m)=fact[n]/fact[m]/fact[n-m]
</span></span></span><span class=line><span class=cl><span class=cm> *！！！最常用！！！	
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=c1>// 快速幂求逆元计算组合数，需要mod是质数，否则用exgcd求逆元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ll</span> <span class=nf>C</span><span class=p>(</span><span class=n>ll</span> <span class=n>n</span><span class=p>,</span> <span class=n>ll</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=o>||</span> <span class=n>m</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>fact</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>*</span> <span class=n>qmi</span><span class=p>(</span><span class=n>fact</span><span class=p>[</span><span class=n>m</span><span class=p>],</span> <span class=n>mod</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span> <span class=o>*</span> <span class=n>qmi</span><span class=p>(</span><span class=n>fact</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=n>m</span><span class=p>],</span> <span class=n>mod</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ll</span> <span class=nf>lucas</span><span class=p>(</span><span class=n>ll</span> <span class=n>n</span><span class=p>,</span> <span class=n>ll</span> <span class=n>m</span><span class=p>)</span> <span class=c1>// 模数mod小于等于n或m时需要用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>lucas</span><span class=p>(</span><span class=n>n</span><span class=o>/</span><span class=n>mod</span><span class=p>,</span> <span class=n>m</span><span class=o>/</span><span class=n>mod</span><span class=p>)</span> <span class=o>*</span> <span class=n>C</span><span class=p>(</span><span class=n>n</span><span class=o>%</span><span class=n>mod</span><span class=p>,</span> <span class=n>m</span> <span class=o>%</span><span class=n>mod</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm> *方法2：递推法 O(nm)
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>i</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>j</span><span class=p>)</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm> *方法3：固定一维递推
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=n>C</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span> <span class=o>=</span> <span class=n>C</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>C</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span> <span class=o>=</span> <span class=n>C</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>/</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm> *方法4：分解质因数求组合数
</span></span></span><span class=line><span class=cl><span class=cm> *比较适用于高精度, 也适用于模数 p 没有逆元的情况
</span></span></span><span class=line><span class=cl><span class=cm> *令N = max(n, m),时间复杂度为 O（N）
</span></span></span><span class=line><span class=cl><span class=cm> ********************************************************
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=c1>// 非高精度版本。n, m 是int范围, n &gt;= m &gt;= 0 ;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=n>ans</span> <span class=o>+=</span> <span class=n>n</span> <span class=o>/</span> <span class=n>p</span><span class=p>,</span> <span class=n>n</span> <span class=o>/=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>C</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>cnt</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=n>prime</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>get</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=n>get</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=n>get</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ans</span> <span class=o>=</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>ans</span> <span class=o>*</span> <span class=n>qmi</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 高精度版：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=n>ans</span> <span class=o>+=</span> <span class=n>n</span> <span class=o>/</span> <span class=n>p</span><span class=p>,</span> <span class=n>n</span> <span class=o>/=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>C</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ans</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>cnt</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=n>prime</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>get</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=n>get</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=n>get</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>s</span><span class=o>--</span><span class=p>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>mul</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>$$
C(n,m)=C(n,n-m)
$$</p></li><li><p>$$
C(n,m)=C(n−1,m−1)+C(n−1,m)
$$</p></li><li><p>$$
C(n, m) = \frac{A(n, m)} { m!}
$$</p></li><li><p>$$
C(n, m) = C(n, m - 1) ⋅ \frac{n - m + 1} {m} = C(n - 1, m) ⋅ \frac{n} { n - m}
$$</p></li><li><p>$$
C(n,0)+C(n,1)+&mldr;+C(n,n)=\sum_{i=0}^n C(n,i)=2^n
$$</p></li><li><p>$$
C(n,0)-C(n,1)+&mldr;+(-1)^nC(n,n)=\sum_{i=0}^n(-1)^iC(n,i)=[n=0]
$$</p><hr></li><li><p>范德蒙德卷积公式：
$$
C_n^0C_m^k+C_n^1C_m^{k-1}+&mldr;+C_n^kC_m^0=\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k
$$
从意义上理解即可，也就是从数量为 $n$ 和 $m$ 的两个堆中一共选择 $k$​​​ 个物品。</p></li><li><p>$$
C_n^0C_m^0+C_n^1C_m^1+&mldr;+C_n^mC_m^m=\sum_{i=0}^mC_n^iC_m^i=\sum_{i=0}^mC_n^iC_m^{m-i}=C_{n+m}^m
$$</p><p>由7变换</p></li><li><p>$$
(C_n^0)^2+(C_n^1)^2+&mldr;+(C_n^n)^2=\sum_{i=0}^n(C_n^i)^2=C_{2n}^n
$$
由7变换</p></li><li><p>$$
C_n^0C_n^1+C_n^1C_n^2+&mldr;+C_n^{n-1}C_n^n=\sum_{i=1}^nC_n^{i-1}C_n^i=C_{2n}^{n-1}
$$
由7变换，令$m=n$，$k=n-1$​</p></li><li><p>$$
kC_n^k=nC_{n-1}^{k-1}
$$</p></li><li><p>$$
1C_n^1+2C_n^2+3C_n^3+&mldr;+nC_n^n=\sum_{i=0}^niC_n^i=n2^{n-1}
$$</p><p>对多项式函数求导</p></li><li><p>$$
1^2C_n^1+2^2C_n^2+3^2C_n^3+&mldr;+n^2C_n^n=\sum_{i=0}^ni^2C_n^i=n(n+1)2^{n-2}
$$
对多项式函数求导</p></li><li><p>$$
1(C_n^1)^2+2(C_n^2)^2+3(C_n^3)^2+&mldr;+n(C_n^n)^2=\sum_{i=0}^ni(C_n^i)^2=nC_{2n-1}^{n-1}
$$</p><p>由11代换，9变形</p></li><li><p>$$
C_l^k+C_{l+1}^k+&mldr;+C_r^k=C_{r+1}^{k+1}-C_l^{k+1}
$$</p><p>式子左侧加$C_l^{k+1}$​​再化简</p></li><li><p>$$
C_n^0+C_{n-1}^1+C_{n-2}^2+&mldr;+C_0^n=\sum_{i=0}^nC_{n-i}^i=F_{n+1},\ \ \ \ \ F是斐波那契数列
$$</p></li><li><p>$$
令f(n,k)=C_n^0+C_n^1+&mldr;+C_n^k=\sum_{i=0}^kC_n^i\\
则有f(n,k)=2*f(n-1,k)-C_{n-1}^k
$$</p><p>错位相加即可得到：</p><p>递推计算$f(0,k)$，$f(1,k)$,&mldr;,$f(n,k)$：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2ll</span> <span class=o>*</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>%</span> <span class=n>mod</span> <span class=o>-</span> <span class=n>C</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>k</span><span class=p>))</span> <span class=o>%</span> <span class=n>mod</span><span class=p>,</span> <span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>mod</span><span class=p>)</span> <span class=o>%=</span> <span class=n>mod</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=7常用组合计数方法>7.常用组合计数方法<a hidden class=anchor aria-hidden=true href=#7常用组合计数方法>#</a></h2><ol><li><p>递推法计数：</p><p>长度为 $n$ 的 $01$ 序列, 每个位置可以任取 $0$ 或 $1$, 要求相邻两个 $1$ 之间隔着至少 $k$ 个 $0$
求合法的序列数：</p><p>设 $f(i)$ 为最后一个 $1$ 在 位置 $i$ 的所有合法序列数，</p><p>则 $f(i) = f(0) + f(1) + f(2) + &mldr; + f(i - k - 1) \ \ \ \ \ \ (f(0) \equiv 1)$</p></li><li><p>隔板法</p></li><li><p>增量法（化相等为不等）</p><p>给定三个正整数 $N,L,R$，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量。</p><p>对于长度为 $k$ 的合法序列：
$$
L\leq a_1\leq a_2\leq &mldr;\leq a_k\leq R
$$
映射到序列 $b_i=a_i+i-1$：
$$
L\leq b_1&lt;b_2&lt;&mldr;&lt;b_k\leq R+k-1
$$
因此长度为 $k$ 的合法序列数量为 $C_{R-L+k}^{k}$ 。</p><p>所以最后答案为 $\sum_{k=1}^{N}C_{R-L+k}^k=C_{R-L+N+1}^{R-L+1}-1$。</p></li></ol><h1 id=四常见序列及性质>四.常见序列及性质<a hidden class=anchor aria-hidden=true href=#四常见序列及性质>#</a></h1><h2 id=1斐波那契数列>1.斐波那契数列<a hidden class=anchor aria-hidden=true href=#1斐波那契数列>#</a></h2><p>递推式为：</p><p>$F_n=F_{n−1}+F_{n−2},\ \ \ F_1=F_2=1$</p><p>根据递推式可以推出一些恒等式：</p><ul><li>$F^2_1+F^2_2+⋯+F^2_n=F_nF_{n+1}$</li></ul><p>将$F_i$用$F_{i+1}−F_{i−1}$表示，那么$F^2_i=F_iF_{i+1}−F_iF_{i−1}$，所有累加起来即可得到等式右边。</p><ul><li>$F_1+F_2+⋯+F_n=F_{n+2}−1$</li></ul><p>用$F_{i+2}−F_{i+1}$表示$F_i$即可。</p><ul><li>$F_1+F_3+⋯+F_{2n−1}=F_{2n}$</li></ul><p>$F_{2i+1}=F_{2i+2}−F_{2i}$，然后累加起来即可。</p><ul><li>$F_{2n}=F_{n−1}F_n+F_nF_{n+1}$</li></ul><p>证明的话可以将斐波那契线性递推写成矩阵的形式就一目了然了。</p><ul><li>$F_{n−1}F_{n+1}−F_{n}^2=(−1)^n$</li></ul><p>数学归纳法可证。</p><p>除开恒等式外，还有一些其它的性质：</p><ul><li>每3个连续的数中有且只有一个被2整除</li><li>每4个连续的数中有且只有一个被3整除，</li><li>每5个连续的数中有且只有一个被5整除，</li><li>每6个连续的数中有且只有一个被8整除，</li><li>每7个连续的数中有且只有一个被13整除，</li><li>个位数每60步一循环，后两位数每300步一循环，后三位数，每1500步一循环，后4位数每15000步一循环，后5位数每150000步一循环</li></ul><p>斐波那契的通项，用母函数随便求啦。</p><h2 id=2卡特兰数>2.卡特兰数<a hidden class=anchor aria-hidden=true href=#2卡特兰数>#</a></h2><p>给定 $n$ 个 $0$ 和 $n$ 个 $1$，它们按照某种顺序排成长度为 $2n$ 的序列，满足任意前缀中 $0$ 的个数都不少于 $1$ 的个数的序列数量。</p><ul><li><p>卡特兰数的<strong>递推式</strong>:
$$
C_{n} = C_0C_{n-1} + C_1C_{n-2} + &mldr;+C_{n-1}C_0 =\sum_{i=0}^{n-1}C_iC_{n-i-1}
$$</p></li><li></li><li><p>求解<strong>通项</strong>，比较简便的话可以用格路模型来解，为：
$$
C_n=C_{2n}^n−C_{2n}^{n−1}=\frac{C_{2n}^{n}}{n+1}
$$</p></li><li><p>h(0)=1,h(1)=1,h(2)=2,h(3)=5,h(4)=14,h(5)=42,&mldr;&mldr;</p></li></ul><p>卡特兰数有一些经典的模型：进出栈问题、二叉树构成、划分三角形等等。
一般的特征就是：在问题中始终存在一个 $≥$ 关系，比如进出栈问题，保证入栈数不小于出栈数；括号问题，左括号数不小于右括号数等等。</p><p><strong>以下问题都与Catalan数有关</strong></p><ol><li><p>$n$ 个左括号和 $n$ 个右括号形成的合法括号序列数量为$Cat(n)$</p></li><li><p>$1,2,&mldr;,n$ 经过一个栈,形成的合法出栈序列数量为$Cat(n)$</p></li><li><p>$n$ 个节点构成构成的不同二叉树的数量为 $Cat(n)$</p></li><li><p>在平面直角坐标系上, 每一步只能向上或向右走, 从 $(0, 0)$ 走到 $(n, n)$ 并且除两个端点外不接触直线 $y = x$ 的路线数量为</p><p>$2Cat(n-1)$</p></li></ol><p><strong>例：</strong></p><p>网格图，左下角为 $A(0,0)$，右上角为 $B(n,m)$，其中 $n\geq m$。</p><p>现在从 $A$ 点出发，只能向正右方或者正上方行走，且不能经过图示中直线左上方的点，即任何途径的点 $(x,y)$ 都要满足 $x≥y$，问在这些前提下，到达 $B$ 有多少种走法。</p><p><img loading=lazy src=https://cdn.acwing.com/media/article/image/2020/01/03/19_90c130462d-1.png alt=示意图,取自acwing></p><p><strong>解：</strong></p><p>同样只需要找到 $B$ 关于 $y=x+1$ 直线的对称点 $C(m-1,n+1)$，总方案数减去 $A$ 到 $C$ 的方案数即可。</p><p>答案为：$C_{n+m}^n-C_{n+m}^{m-1}$</p><h2 id=3斯特林数>3.斯特林数<a hidden class=anchor aria-hidden=true href=#3斯特林数>#</a></h2><h3 id=31-第一类斯特林数>3.1 第一类斯特林数<a hidden class=anchor aria-hidden=true href=#31-第一类斯特林数>#</a></h3><p>第一类斯特林数表示的是将$n$个数分为$k$个圆环的方案数，两个圆环不同当且仅当一个圆环通过旋转不能得到另一圆环。</p><p>第一斯特林数（无符号）</p><p><strong>定义：</strong> $1$~$n$的$n$个两两不同的元素划分成$k$个圆排列的方案数，记作 $s_u(n, k)$</p><p><strong>递推公式：$s_u(n, k) = s_u(n-1, k -1) + (n-1)\times s_u(n - 1, k)$</strong></p><p>分别表示当前第$n$个数和之前的划分在一起还是单独成一个圈，和其它元素在一起的话那么有$n-1$种可能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// O(nm)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=n>ll</span><span class=p>)(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>%</span> <span class=n>mod</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=32-第二类斯特林数>3.2 第二类斯特林数<a hidden class=anchor aria-hidden=true href=#32-第二类斯特林数>#</a></h3><p>虽然被称作“第二类”，第二类斯特林数却在斯特林的相关著作和具体数学中被首先描述，同时也比第一类斯特林数常用得多。</p><p><strong>第二类斯特林数</strong>（斯特林子集数）$\left\{\begin{matrix} n\\ k \end{matrix} \right\}$，也可记做 $S(n,k)$，表示将 $n$ 个两两不同的元素，划分为 $k$ 个互不区分的非空子集的方案数。</p><h4 id=递推式>递推式<a hidden class=anchor aria-hidden=true href=#递推式>#</a></h4><p>$$
\left\{\begin{matrix} n\\ k \end{matrix} \right\}=\left\{\begin{matrix} n-1\\ k-1 \end{matrix} \right\}+k\left\{\begin{matrix} n-1\\ k \end{matrix} \right\}
$$</p><p>边界是：$\left\{\begin{matrix} n\\ 0 \end{matrix} \right\}=[n=0]$。</p><p>其实也就是动态规划，从组合意义上考虑。</p><p>新加入一个元素时，有两种方案：</p><ul><li>将新元素单独放入一个子集，有 $\left\{\begin{matrix} n-1\\ k-1 \end{matrix} \right\}$ 种方案；</li><li>将新元素放入一个现有的非空子集，有 $k\left\{\begin{matrix} n-1\\ k \end{matrix} \right\}$ 种方案。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// O(nm)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>j</span> <span class=o>*</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>%</span> <span class=n>mod</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>性质</strong>
同第一类斯特林数，第二类斯特林数也有一些简单的性质：</p><ul><li>$S(0,0)=S(n,n)=1$</li><li>$S(n,0)=S(0,n)=0,\ \ n>0$</li><li>$S(n,n−1)=C(n,2)$</li><li>$S(n,n−2)=C(n,3)+3C(n,4)$</li></ul><p>分两种情况然后加起来即可。</p><ul><li>$S(n,2)=2^{n−1}−1$</li></ul><p>直接归纳证即可。还有一种比较简单的方法，就是先钦定一个球在一个盒子中，然后剩下n−1n−1个球每个球就有两种可能，最后再减去不合法的一种情况即可。</p><h4 id=通项公式>通项公式<a hidden class=anchor aria-hidden=true href=#通项公式>#</a></h4><p>$$
\left\{\begin{matrix} n\\ m \end{matrix} \right\}=\sum_{i=0}^{m}\frac{(-1)^{m-i}i^n}{i!(m-i)!}
$$</p><p>另外，第二类斯特林数还有通项公式，可以用容斥的思想去想，即枚举至少有几个空集合，然后小球可以在其它集合中随便放。公式如下：</p><p>可以注意到这是一个卷积的形式，那么我们可以用$NTT$在$O(mlogm)$的时间内快速求出$S(n,1),S(n,2),⋯,S(n,m)$的通项。</p><p>第二类斯特林数还有一个比较有用的公式：</p><p>$$
m^n=∑_{i=0}^mC(m,i)⋅i!⋅S(n,i)
$$
$m^n$意即将$n$个小球放入$m$个集合中，允许空盒。
我们可以枚举最终是几个集合，然后从将其从$m$中选出来并标号，最后将$n$个小球放入这$i$个盒子，所有情况加起即为$m^n$。</p><p>最后再附加一个公式，可以用来处理一些有关$n!$的信息：</p><p>$n!≈\sqrt{2πn}(\frac{n}{e})^n$</p><p>我们可以几乎认为这两者相等。</p><h1 id=五置换群>五.置换群<a hidden class=anchor aria-hidden=true href=#五置换群>#</a></h1><p>这部分内容有点不好理解。。所以更多是直观上的阐述。
这部分知识应该是对于一类涉及“本质不同”的计数问题的补充，通常这类问题具有比较好的对称性质。</p><p><a href=https://fanfansann.blog.csdn.net/article/details/113763883>https://fanfansann.blog.csdn.net/article/details/113763883</a></p><h2 id=1burnside-引理>1.Burnside 引理<a hidden class=anchor aria-hidden=true href=#1burnside-引理>#</a></h2><p><strong>$N(G,C)=\frac{1}{|G|}\sum_{f_i∈G}|C(f_i)|$</strong></p><p>其中 $∣ C ( f_ i ) ∣$表示不动点集合$ C ( f _i ) $的个数。</p><p>$N$表示 使用 $m $ 种颜色给 $n$个对象染色的总方案数</p><p>$|G|$代表置换个数</p><p><strong>每个置换的不动点的个数的平均值就是不同的方案数</strong>。</p><h2 id=2polya-定理>2.Polya 定理<a hidden class=anchor aria-hidden=true href=#2polya-定理>#</a></h2><p><strong>$N=\frac{1}{|G|}\sum_{f_i∈G}k^{m(f_i)}$</strong></p><p>其中$m(f_i)$是置换$f_i$的循环个数</p><p><strong>相当于计算了Burnside引理中的$C(f_i)$</strong></p><h3 id=21-旋转置换>2.1 旋转置换<a hidden class=anchor aria-hidden=true href=#21-旋转置换>#</a></h3><p>$n$个点，用$k$种颜色染色</p><p>每个点移动$i$步（$0 ≤ i ≤ n − 1$），循环个数为：$gcd(i,n)$</p><p>总共：$n$个置换，$a = \sum_{i = 0}^{n-1}k^{gcd(i,n)}$个不动点</p><h3 id=22-翻转置换>2.2 翻转置换<a hidden class=anchor aria-hidden=true href=#22-翻转置换>#</a></h3><p>$n$个点，用$k$种颜色染色</p><ol><li><p>$n$为奇数，对称轴有$n$条，形成$\frac{n-1}{2}$个长度为2的循环，1个长度为1的循环，因此总共有$\frac{n+1}{2}$个循环。</p><p>总共：$n$个置换，$b=nk^{\frac{n+1}{2}}$个不动点。</p></li><li><p>n为偶数：</p><p>①对称轴穿过两个点：有$\frac{n}{2}$个对称轴，每一个对称轴有$\frac{n}{2}+1$个循环</p><p>②对称轴穿过两个边：有$\frac{n}{2}$个对称轴，每一个对称轴有$\frac{n}{2}$个循环</p><p>总共：$n$个置换，$b=\frac{n}{2}(k^{\frac{n}{2}+1}+k^{\frac{n}{2}})$个不动点</p></li></ol><h3 id=23-小结论>2.3 小结论<a hidden class=anchor aria-hidden=true href=#23-小结论>#</a></h3><p>只考虑旋转是本质不同，用 <img loading=lazy src="https://www.zhihu.com/equation?tex=m" alt=[公式]>
种颜色给 <img loading=lazy src="https://www.zhihu.com/equation?tex=n" alt=[公式]>
元环染色的方案数为：</p><p><img loading=lazy src="https://www.zhihu.com/equation?tex=M%3D%5Cfrac1%7Bn%7D%5Csum_%7Bk%3D0%7D%5E%7Bn-1%7Dm%5E%7B%5Cgcd%28k%2Cn%29%7D%3D%5Cfrac1%7Bn%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7Dm%5E%7B%5Cgcd%28k%2Cn%29%7D" alt=[公式]></p><p>继续莫比乌斯反演那一套方法，枚举公因数化简：</p><p><img loading=lazy src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+M%26%3D%5Cfrac1%7Bn%7D%5Csum_%7Bd%7Cn%7Dm%5E%7Bd%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5B%5Cgcd%28i%2Cn%29%3Dd%5D+%5C%5C%26%3D+%5Cfrac1%7Bn%7D%5Csum_%7Bd%7Cn%7Dm%5E%7Bd%7D%5Csum_%7Bj%3D1%7D%5E%7Bn%2Fd%7D%5B%5Cgcd%28jd%2C%5Cfrac+ndd%29%3Dd%5D+%5C%5C%26%3D+%5Cfrac1%7Bn%7D%5Csum_%7Bd%7Cn%7Dm%5E%7Bd%7D%5Csum_%7Bj%3D1%7D%5E%7Bn%2Fd%7D%5B%5Cgcd%28j%2C%5Cfrac+nd%29%3D1%5D+%5C%5C%26%3D+%5Cfrac1%7Bn%7D%5Csum_%7Bd%7Cn%7Dm%5E%7Bd%7D%5Cvarphi%28%5Cfrac+nd%29+%5Cend%7Balign%7D" alt=[公式]></p><p>暴力代码$O(约数个数*logn*n^\frac{1}{2})$（可能没有这么慢？）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>qmi</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>b</span><span class=p>;</span> <span class=n>b</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span> <span class=n>ans</span> <span class=o>*</span> <span class=n>a</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>a</span> <span class=o>*</span> <span class=n>a</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>phi</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ans</span> <span class=o>=</span> <span class=n>ans</span> <span class=o>/</span> <span class=n>i</span> <span class=o>*</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>n</span> <span class=o>/=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>ans</span> <span class=o>/</span> <span class=n>n</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>t</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span> <span class=o>=</span> <span class=p>((</span><span class=n>ll</span><span class=p>)</span><span class=n>res</span> <span class=o>+</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>qmi</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=o>*</span> <span class=n>phi</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>((</span><span class=n>ll</span><span class=p>)</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>res</span> <span class=o>=</span> <span class=p>((</span><span class=n>ll</span><span class=p>)</span><span class=n>res</span> <span class=o>+</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>qmi</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>n</span> <span class=o>/</span> <span class=n>i</span><span class=p>)</span> <span class=o>*</span> <span class=n>phi</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=p>(</span><span class=n>ll</span><span class=p>)</span><span class=n>res</span> <span class=o>*</span> <span class=n>qmi</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>mod</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span> <span class=o>%</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=六生成函数>六.生成函数<a hidden class=anchor aria-hidden=true href=#六生成函数>#</a></h1><p>又叫母函数。</p><p>生成函数可以将乘法原理与多项式乘法相联系起来。</p><h2 id=1常用无穷级数>1.常用无穷级数<a hidden class=anchor aria-hidden=true href=#1常用无穷级数>#</a></h2><p>对于$x∈(-1,1)，$$A(x)=x_0 + x_1+x_2+&mldr;+x_k+&mldr; \ = \frac{1}{1-x}$ 。</p><p>推广：
对于$x∈(-1,1)，$$A(x)=\sum_{i = 0}^{∞}{C_{i+n-1}^{n-1}x^i}\ = \frac{1}{(1-x)^n}$ 。</p><h2 id=2例子>2.例子<a hidden class=anchor aria-hidden=true href=#2例子>#</a></h2><p>1，2，6三个重量的砝码有无穷多个，用这些砝码组合称出重量为n的方案数:
$A_1(x)=1+x^1+x^2+&mldr;$
$A_2(x)=1+x^2+x^4+&mldr;$
$A_6(x)=1+x^6+x^{12}+&mldr;$
答案多项式就为$A(x)=A_1(x)*A_2(x)*A_3(x)$</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://liuyilong.com/tags/acm/>ACM</a></li><li><a href=https://liuyilong.com/tags/%E6%95%B0%E5%AD%A6/>数学</a></li></ul><nav class=paginav><a class=prev href=https://liuyilong.com/p/tech/test/><span class=title>« 上一页</span><br><span>Test</span></a>
<a class=next href=https://liuyilong.com/p/tech/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/><span class=title>下一页 »</span><br><span>二项式反演</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.10/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo-api-peach-psi.vercel.app/",el:"#tcomment",lang:"zh-CN",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://liuyilong.com>liuyl's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a><br></span><span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>