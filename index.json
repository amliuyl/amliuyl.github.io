[{"content":"/* ******************************************************** *方法1：C(n,m)=fact[n]/fact[m]/fact[n-m] *！！！最常用！！！\t******************************************************** */ // 快速幂求逆元计算组合数，需要mod是质数，否则用exgcd求逆元 ll C(ll n, ll m) { if (n \u0026lt; m || m \u0026lt; 0) return 0; return fact[n] * qmi(fact[m], mod-2) % mod * qmi(fac[n-m], mod-2) % mod; } ll lucas(ll n, ll m) // 模数mod小于等于n或m时需要用 { if (m == 0) return 1; return lucas(n/mod, m/mod) * C(n%mod, m %mod) % mod; } /* ******************************************************** *方法2：递推法 O(nm) ******************************************************** */ for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt;= m; j++) if (!j) f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; /* ******************************************************** *方法3：固定一维递推 ******************************************************** */ C(n, m) = C(n, m - 1) * (n - m + 1) / m; C(n, m) = C(n - 1, m) * n / (n - m); /* ******************************************************** *方法4：分解质因数求组合数 *比较适用于高精度, 也适用于模数 p 没有逆元的情况 *令N = max(n, m),时间复杂度为 O（N） ******************************************************** */ // 非高精度版本。n, m 是int范围, n \u0026gt;= m \u0026gt;= 0 ; int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } int C(int n, int m) { int ans = 1; for (int i = 1; i \u0026lt;= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); ans = (ll)ans * qmi(p, s) % mod; } return ans; } // 高精度版： int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } vector\u0026lt;int\u0026gt; C(int n, int m) { vector\u0026lt;int\u0026gt; ans; ans.push_back(1); for (int i = 1; i \u0026lt;= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); while (s--) ans = mul(ans, p); } return ans; } ","permalink":"https://liuyilong.com/p/tech/test/","summary":"/* ******************************************************** *方法1：C(n,m)=fact[n]/fact[m]/fact[n-m] *！！！最常用！！！ ******************************************************** */ // 快速幂求逆元计算组合数，需要mod是","title":"Test"},{"content":"一.基本法则 1.加法法则 设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$或$B$”共有$m+n$种产生方式。\n加法法则注重于分类问题的解决。\n2.乘法法则 设事件$A$有$m$种产生方式，事件$B$有$n$种产生方式，事件$A$与事件$B$相互独立，那么“事件$A$与$B$”共有$m∗n$种产生方式。\n乘法法则注重于分步问题的解决。\n二.排列 1.不可重排列 从$n$个不同的元素中取出$r$个元素，按次序排列的方案数，称作从$n$个中取$r$个的无重排列，用$A(n,r)$表示。 $$ A_n^r=\\frac{n!}{(n-r)!} $$\n2.可重排列数 从$n$​个不同元素中取$r$​个元素，每个元素可以重复取，方案数为 $n^r$ ​，即每个位置有$n$​个选择，共$r$​个位置。\n3.圆排列 从$n$​个不同元素中取出$r$​个元素形成一个环，最终环的个数。方案数为: $$ \\frac{A(n,r)}{r}\\ \\ \\ \\ \\ \\ \\ \\ ,2\\leq r\\leq n $$ 即先考虑所有的排列情况并将其连接成环，一个环从中间断开会形成$r$个序列，那么所有的情况除以$r$则得到最终方案数。\n4.项链排列 从$n$个不同元素中取出$r$个元素形成一个圆项链，最终项链个数。\n类似于圆排列，但是项链可以翻转，正面向上和反面向上两种方式放置各个数是同一个排列，所以方案数为： $$ \\frac{A(n,r)}{2r}\\ \\ \\ \\ \\ \\ \\ \\ ,3\\leq r\\leq n $$\n5.多重集的排列 多重集的排列数也称为多重组合数，是有重$n$个元素的全排列，要区别于多重集的组合数，两者是完全不同的概念！\n设元素$a_1,a_2,⋯,a_k$​互不相同，每个元素有$n_i$​​个，$n_1+n_2+\u0026hellip;+n_k=n$​，那么所有元素的全排列为： $$ \\frac{n!}{n_1!n_2!\u0026hellip;n_k!} $$ 可记为 $\\tbinom{n}{n_1,n_2,\u0026hellip;,n_k}$\n可以理解为：先将所有的元素打上标号，那么就全为不同的元素，此时方案数为$n!$，之后对于每一类元素消除其冗余度$n_i!$即可。\n带限制的排列问题可以用指数型母函数解决。\n三.组合 1.无重组合 从$n$​个不同元素中取出$r$个元素，不考虑元素之间的顺序时，总的方案数。记为$C(n,r)$或者$\\tbinom{n}{r}$​​​。 有公式： $$ C(n,r)=\\frac{n!}{r!(n-r)!} $$\n2.可重组合 从$n$个不同元素中取出$r$个数，每个元素可以重复取（相当于每种元素都有大于等于$r$个）的组合方案数。\n可以将问题等价于：把$r$个元素划分成$n$类，每类元素个数没有要求。\n那么方案数即为： $$ C(r+n−1,n−1) $$ 相当于求解$x_1+x_2+⋯+x_n=r$的非负整数解的方案数，采用隔板法即可求解。\n3.多重集的组合 设$S=$ { $n_1⋅a_1,n_2⋅a_2,\u0026hellip;,n_k⋅a_k$ }表示由$n_1$个$a_1$, $n_2$个$a_2$ ,…，$n_k$个$a_k$组成的多重集。那么对于整数$r$，从$S$中选择$r$个元素组成一个多重集的方案数就是多重集的组合数。\n是可重组合的一般化，可重组合较为特殊的是每个元素是有无限个可以取。\n可用普通母函数解决。\n4.不相邻组合 从 $A=$ { $1,2,⋯,n$ } 中取 $r$ 个不相邻的组合方案数，其组合数为 $$ C(n-r+1,r) $$ 可采用标号法来求解，假设选取任意一个解 $S=$ { $1,3,⋯,n$ }。\n因为是组合，我们将其按照升序排列，对应位置的下标为 { $0,1,⋯,r−1$​ }。\n我们将元素与对应下标相减（去掉限制条件），那么有 $S^′=$ { $1,2,⋯,n−r+1$ }。易知问题转变成了从 $n−r+1$个数中选取 $r$ 个数的组合数。这两者的方案数是一一对应的。\n相同的方法可以用来求解可重组合数，只是我们要累加元素的下标（可以去掉重复），同样可以得到上述结果。\n5.基本公式 组合数为二项式定理展开式中对应项的系数： $$ (x+y)^n=\\sum_{i=0}^nC(n,i)x^iy^{n-i} $$ 相当于$(x+y)⋅(x+y)⋅⋯⋅(x+y)$ 中，每一项只会选取一个，那么若$x$选取了$i$个，对应$y$选取了$n−i$ 个，方案数为$C(n,i)=C(n,n−i)$。\n根据这个，令$x=y=1$则有：\n$$ \\sum_{i=0}^n C(n,i)=2^n $$ 令$x=1,y=−1$有：\n$$ \\sum_{i=0}^n(-1)^iC(n,i)=0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ , n\\neq0 $$ 还有些其它的式子：\n$$ C(n,m)=C(n−1,m−1)+C(n−1,m) $$ 考虑第$m$个元素选还是不选，分类过后加起来即可。\n$$ C(n,m)⋅C(m,r)=C(n,r)⋅C(n−r,m−r) $$ 另外，二项式定理还可以扩展为多项式定理：\n$$ (x_1+x_2+⋯+x_t)^n=\\sum_{n_1+⋯+n_t=n}\\tbinom {n}{n_1,n_2,⋯,n_t}{x_1}^{n_1}{x_2}^{n_2}\u0026hellip;{x_t}^{n_t} $$ 原理是 $$ C(n,n_1)⋅C(n−n_1,n_2)⋅⋯⋅C(n−n_1−n_2−⋯−n_{t−1},n_t)=\\tbinom {n}{n_1,n_2,⋯,n_t} $$ 可见多项式的系数刚好对应多重集的排列个数。\n6.常用公式 求组合数\n/* ******************************************************** *方法1：C(n,m)=fact[n]/fact[m]/fact[n-m] *！！！最常用！！！\t******************************************************** */ // 快速幂求逆元计算组合数，需要mod是质数，否则用exgcd求逆元 ll C(ll n, ll m) { if (n \u0026lt; m || m \u0026lt; 0) return 0; return fact[n] * qmi(fact[m], mod-2) % mod * qmi(fact[n-m], mod-2) % mod; } ll lucas(ll n, ll m) // 模数mod小于等于n或m时需要用 { if (m == 0) return 1; return lucas(n/mod, m/mod) * C(n%mod, m %mod) % mod; } /* ******************************************************** *方法2：递推法 O(nm) ******************************************************** */ for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt;= m; j++) if (!j) f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; /* ******************************************************** *方法3：固定一维递推 ******************************************************** */ C(n, m) = C(n, m - 1) * (n - m + 1) / m; C(n, m) = C(n - 1, m) * n / (n - m); /* ******************************************************** *方法4：分解质因数求组合数 *比较适用于高精度, 也适用于模数 p 没有逆元的情况 *令N = max(n, m),时间复杂度为 O（N） ******************************************************** */ // 非高精度版本。n, m 是int范围, n \u0026gt;= m \u0026gt;= 0 ; int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } int C(int n, int m) { int ans = 1; for (int i = 1; i \u0026lt;= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); ans = (ll)ans * qmi(p, s) % mod; } return ans; } // 高精度版： int get(int n, int p) { int ans = 0; while (n) ans += n / p, n /= p; return ans; } vector\u0026lt;int\u0026gt; C(int n, int m) { vector\u0026lt;int\u0026gt; ans; ans.push_back(1); for (int i = 1; i \u0026lt;= cnt; i++) { int p = prime[i]; int s = get(n, p) - get(m, p) - get(n - m, p); while (s--) ans = mul(ans, p); } return ans; } $$ C(n,m)=C(n,n-m) $$\n$$ C(n,m)=C(n−1,m−1)+C(n−1,m) $$\n$$ C(n, m) = \\frac{A(n, m)} { m!} $$\n$$ C(n, m) = C(n, m - 1) ⋅ \\frac{n - m + 1} {m} = C(n - 1, m) ⋅ \\frac{n} { n - m} $$\n$$ C(n,0)+C(n,1)+\u0026hellip;+C(n,n)=\\sum_{i=0}^n C(n,i)=2^n $$\n$$ C(n,0)-C(n,1)+\u0026hellip;+(-1)^nC(n,n)=\\sum_{i=0}^n(-1)^iC(n,i)=[n=0] $$\n范德蒙德卷积公式： $$ C_n^0C_m^k+C_n^1C_m^{k-1}+\u0026hellip;+C_n^kC_m^0=\\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k $$ 从意义上理解即可，也就是从数量为 $n$ 和 $m$ 的两个堆中一共选择 $k$​​​ 个物品。\n$$ C_n^0C_m^0+C_n^1C_m^1+\u0026hellip;+C_n^mC_m^m=\\sum_{i=0}^mC_n^iC_m^i=\\sum_{i=0}^mC_n^iC_m^{m-i}=C_{n+m}^m $$\n由7变换\n$$ (C_n^0)^2+(C_n^1)^2+\u0026hellip;+(C_n^n)^2=\\sum_{i=0}^n(C_n^i)^2=C_{2n}^n $$ 由7变换\n$$ C_n^0C_n^1+C_n^1C_n^2+\u0026hellip;+C_n^{n-1}C_n^n=\\sum_{i=1}^nC_n^{i-1}C_n^i=C_{2n}^{n-1} $$ 由7变换，令$m=n$，$k=n-1$​\n$$ kC_n^k=nC_{n-1}^{k-1} $$\n$$ 1C_n^1+2C_n^2+3C_n^3+\u0026hellip;+nC_n^n=\\sum_{i=0}^niC_n^i=n2^{n-1} $$\n对多项式函数求导\n$$ 1^2C_n^1+2^2C_n^2+3^2C_n^3+\u0026hellip;+n^2C_n^n=\\sum_{i=0}^ni^2C_n^i=n(n+1)2^{n-2} $$ 对多项式函数求导\n$$ 1(C_n^1)^2+2(C_n^2)^2+3(C_n^3)^2+\u0026hellip;+n(C_n^n)^2=\\sum_{i=0}^ni(C_n^i)^2=nC_{2n-1}^{n-1} $$\n由11代换，9变形\n$$ C_l^k+C_{l+1}^k+\u0026hellip;+C_r^k=C_{r+1}^{k+1}-C_l^{k+1} $$\n式子左侧加$C_l^{k+1}$​​再化简\n$$ C_n^0+C_{n-1}^1+C_{n-2}^2+\u0026hellip;+C_0^n=\\sum_{i=0}^nC_{n-i}^i=F_{n+1},\\ \\ \\ \\ \\ F是斐波那契数列 $$\n$$ 令f(n,k)=C_n^0+C_n^1+\u0026hellip;+C_n^k=\\sum_{i=0}^kC_n^i\\\\ 则有f(n,k)=2*f(n-1,k)-C_{n-1}^k $$\n错位相加即可得到：\n递推计算$f(0,k)$，$f(1,k)$,\u0026hellip;,$f(n,k)$：\nf[0] = 1; for (int i = 1; i \u0026lt;= n; i++) f[i] = (2ll * f[i - 1] % mod - C(i - 1, k)) % mod, (f[i] += mod) %= mod; 7.常用组合计数方法 递推法计数：\n长度为 $n$ 的 $01$ 序列, 每个位置可以任取 $0$ 或 $1$, 要求相邻两个 $1$ 之间隔着至少 $k$ 个 $0$ 求合法的序列数：\n设 $f(i)$ 为最后一个 $1$ 在 位置 $i$ 的所有合法序列数，\n则 $f(i) = f(0) + f(1) + f(2) + \u0026hellip; + f(i - k - 1) \\ \\ \\ \\ \\ \\ (f(0) \\equiv 1)$\n隔板法\n增量法（化相等为不等）\n给定三个正整数 $N,L,R$，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量。\n对于长度为 $k$ 的合法序列： $$ L\\leq a_1\\leq a_2\\leq \u0026hellip;\\leq a_k\\leq R $$ 映射到序列 $b_i=a_i+i-1$： $$ L\\leq b_1\u0026lt;b_2\u0026lt;\u0026hellip;\u0026lt;b_k\\leq R+k-1 $$ 因此长度为 $k$ 的合法序列数量为 $C_{R-L+k}^{k}$ 。\n所以最后答案为 $\\sum_{k=1}^{N}C_{R-L+k}^k=C_{R-L+N+1}^{R-L+1}-1$。\n四.常见序列及性质 1.斐波那契数列 递推式为：\n$F_n=F_{n−1}+F_{n−2},\\ \\ \\ F_1=F_2=1$\n根据递推式可以推出一些恒等式：\n$F^2_1+F^2_2+⋯+F^2_n=F_nF_{n+1}$ 将$F_i$用$F_{i+1}−F_{i−1}$表示，那么$F^2_i=F_iF_{i+1}−F_iF_{i−1}$，所有累加起来即可得到等式右边。\n$F_1+F_2+⋯+F_n=F_{n+2}−1$ 用$F_{i+2}−F_{i+1}$表示$F_i$即可。\n$F_1+F_3+⋯+F_{2n−1}=F_{2n}$ $F_{2i+1}=F_{2i+2}−F_{2i}$，然后累加起来即可。\n$F_{2n}=F_{n−1}F_n+F_nF_{n+1}$ 证明的话可以将斐波那契线性递推写成矩阵的形式就一目了然了。\n$F_{n−1}F_{n+1}−F_{n}^2=(−1)^n$ 数学归纳法可证。\n除开恒等式外，还有一些其它的性质：\n每3个连续的数中有且只有一个被2整除 每4个连续的数中有且只有一个被3整除， 每5个连续的数中有且只有一个被5整除， 每6个连续的数中有且只有一个被8整除， 每7个连续的数中有且只有一个被13整除， 个位数每60步一循环，后两位数每300步一循环，后三位数，每1500步一循环，后4位数每15000步一循环，后5位数每150000步一循环 斐波那契的通项，用母函数随便求啦。\n2.卡特兰数 给定 $n$ 个 $0$ 和 $n$ 个 $1$，它们按照某种顺序排成长度为 $2n$ 的序列，满足任意前缀中 $0$ 的个数都不少于 $1$ 的个数的序列数量。\n卡特兰数的递推式: $$ C_{n} = C_0C_{n-1} + C_1C_{n-2} + \u0026hellip;+C_{n-1}C_0 =\\sum_{i=0}^{n-1}C_iC_{n-i-1} $$\n求解通项，比较简便的话可以用格路模型来解，为： $$ C_n=C_{2n}^n−C_{2n}^{n−1}=\\frac{C_{2n}^{n}}{n+1} $$\nh(0)=1,h(1)=1,h(2)=2,h(3)=5,h(4)=14,h(5)=42,\u0026hellip;\u0026hellip;\n卡特兰数有一些经典的模型：进出栈问题、二叉树构成、划分三角形等等。 一般的特征就是：在问题中始终存在一个 $≥$ 关系，比如进出栈问题，保证入栈数不小于出栈数；括号问题，左括号数不小于右括号数等等。\n以下问题都与Catalan数有关\n$n$ 个左括号和 $n$ 个右括号形成的合法括号序列数量为$Cat(n)$\n$1,2,\u0026hellip;,n$ 经过一个栈,形成的合法出栈序列数量为$Cat(n)$\n$n$ 个节点构成构成的不同二叉树的数量为 $Cat(n)$\n在平面直角坐标系上, 每一步只能向上或向右走, 从 $(0, 0)$ 走到 $(n, n)$ 并且除两个端点外不接触直线 $y = x$ 的路线数量为\n$2Cat(n-1)$\n例：\n网格图，左下角为 $A(0,0)$，右上角为 $B(n,m)$，其中 $n\\geq m$。\n现在从 $A$ 点出发，只能向正右方或者正上方行走，且不能经过图示中直线左上方的点，即任何途径的点 $(x,y)$ 都要满足 $x≥y$，问在这些前提下，到达 $B$ 有多少种走法。\n解：\n同样只需要找到 $B$ 关于 $y=x+1$ 直线的对称点 $C(m-1,n+1)$，总方案数减去 $A$ 到 $C$ 的方案数即可。\n答案为：$C_{n+m}^n-C_{n+m}^{m-1}$\n3.斯特林数 3.1 第一类斯特林数 第一类斯特林数表示的是将$n$个数分为$k$个圆环的方案数，两个圆环不同当且仅当一个圆环通过旋转不能得到另一圆环。\n第一斯特林数（无符号）\n定义： $1$~$n$的$n$个两两不同的元素划分成$k$个圆排列的方案数，记作 $s_u(n, k)$\n递推公式：$s_u(n, k) = s_u(n-1, k -1) + (n-1)\\times s_u(n - 1, k)$\n分别表示当前第$n$个数和之前的划分在一起还是单独成一个圈，和其它元素在一起的话那么有$n-1$种可能。\n// O(nm) s[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) s[i][j] = (s[i - 1][j - 1] + (ll)(i - 1) * s[i - 1][j] % mod) % mod; 3.2 第二类斯特林数 虽然被称作“第二类”，第二类斯特林数却在斯特林的相关著作和具体数学中被首先描述，同时也比第一类斯特林数常用得多。\n第二类斯特林数（斯特林子集数）$\\left\\{\\begin{matrix} n\\\\ k \\end{matrix} \\right\\}$，也可记做 $S(n,k)$，表示将 $n$ 个两两不同的元素，划分为 $k$ 个互不区分的非空子集的方案数。\n递推式 $$ \\left\\{\\begin{matrix} n\\\\ k \\end{matrix} \\right\\}=\\left\\{\\begin{matrix} n-1\\\\ k-1 \\end{matrix} \\right\\}+k\\left\\{\\begin{matrix} n-1\\\\ k \\end{matrix} \\right\\} $$\n边界是：$\\left\\{\\begin{matrix} n\\\\ 0 \\end{matrix} \\right\\}=[n=0]$。\n其实也就是动态规划，从组合意义上考虑。\n新加入一个元素时，有两种方案：\n将新元素单独放入一个子集，有 $\\left\\{\\begin{matrix} n-1\\\\ k-1 \\end{matrix} \\right\\}$ 种方案； 将新元素放入一个现有的非空子集，有 $k\\left\\{\\begin{matrix} n-1\\\\ k \\end{matrix} \\right\\}$ 种方案。 // O(nm) s[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) s[i][j] = (s[i - 1][j - 1] + (ll)j * s[i - 1][j] % mod) % mod; 性质 同第一类斯特林数，第二类斯特林数也有一些简单的性质：\n$S(0,0)=S(n,n)=1$ $S(n,0)=S(0,n)=0,\\ \\ n\u0026gt;0$ $S(n,n−1)=C(n,2)$ $S(n,n−2)=C(n,3)+3C(n,4)$ 分两种情况然后加起来即可。\n$S(n,2)=2^{n−1}−1$ 直接归纳证即可。还有一种比较简单的方法，就是先钦定一个球在一个盒子中，然后剩下n−1n−1个球每个球就有两种可能，最后再减去不合法的一种情况即可。\n通项公式 $$ \\left\\{\\begin{matrix} n\\\\ m \\end{matrix} \\right\\}=\\sum_{i=0}^{m}\\frac{(-1)^{m-i}i^n}{i!(m-i)!} $$\n另外，第二类斯特林数还有通项公式，可以用容斥的思想去想，即枚举至少有几个空集合，然后小球可以在其它集合中随便放。公式如下：\n可以注意到这是一个卷积的形式，那么我们可以用$NTT$在$O(mlogm)$的时间内快速求出$S(n,1),S(n,2),⋯,S(n,m)$的通项。\n第二类斯特林数还有一个比较有用的公式：\n$$ m^n=∑_{i=0}^mC(m,i)⋅i!⋅S(n,i) $$ $m^n$意即将$n$个小球放入$m$个集合中，允许空盒。 我们可以枚举最终是几个集合，然后从将其从$m$中选出来并标号，最后将$n$个小球放入这$i$个盒子，所有情况加起即为$m^n$。\n最后再附加一个公式，可以用来处理一些有关$n!$的信息：\n$n!≈\\sqrt{2πn}(\\frac{n}{e})^n$\n我们可以几乎认为这两者相等。\n五.置换群 这部分内容有点不好理解。。所以更多是直观上的阐述。 这部分知识应该是对于一类涉及“本质不同”的计数问题的补充，通常这类问题具有比较好的对称性质。\nhttps://fanfansann.blog.csdn.net/article/details/113763883\n1.Burnside 引理 $N(G,C)=\\frac{1}{|G|}\\sum_{f_i∈G}|C(f_i)|$\n其中 $∣ C ( f_ i ) ∣$表示不动点集合$ C ( f _i ) $的个数。\n$N$表示 使用 $m $ 种颜色给 $n$个对象染色的总方案数\n$|G|$代表置换个数\n每个置换的不动点的个数的平均值就是不同的方案数。\n2.Polya 定理 $N=\\frac{1}{|G|}\\sum_{f_i∈G}k^{m(f_i)}$\n其中$m(f_i)$是置换$f_i$的循环个数\n相当于计算了Burnside引理中的$C(f_i)$\n2.1 旋转置换 $n$个点，用$k$种颜色染色\n每个点移动$i$步（$0 ≤ i ≤ n − 1$），循环个数为：$gcd(i,n)$\n总共：$n$个置换，$a = \\sum_{i = 0}^{n-1}k^{gcd(i,n)}$个不动点\n2.2 翻转置换 $n$个点，用$k$种颜色染色\n$n$为奇数，对称轴有$n$条，形成$\\frac{n-1}{2}$个长度为2的循环，1个长度为1的循环，因此总共有$\\frac{n+1}{2}$个循环。\n总共：$n$个置换，$b=nk^{\\frac{n+1}{2}}$个不动点。\nn为偶数：\n①对称轴穿过两个点：有$\\frac{n}{2}$个对称轴，每一个对称轴有$\\frac{n}{2}+1$个循环\n②对称轴穿过两个边：有$\\frac{n}{2}$个对称轴，每一个对称轴有$\\frac{n}{2}$个循环\n总共：$n$个置换，$b=\\frac{n}{2}(k^{\\frac{n}{2}+1}+k^{\\frac{n}{2}})$个不动点\n2.3 小结论 只考虑旋转是本质不同，用 种颜色给 元环染色的方案数为：\n继续莫比乌斯反演那一套方法，枚举公因数化简：\n暴力代码$O(约数个数*logn*n^\\frac{1}{2})$（可能没有这么慢？）\nint qmi(int a, int b) { int ans = 1; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (ll) ans * a % mod; a = (ll)a * a % mod; } return ans; } int phi(int n) { int ans = n; for (int i = 2; (ll)i * i \u0026lt;= n; i++) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n \u0026gt; 1) ans = ans / n * (n - 1); return ans; } int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int res = 0; for (int i = 1; (ll)i * i \u0026lt;= n; i++) { if (n % i == 0) { res = ((ll)res + (ll)qmi(n, i) * phi(n / i) % mod) % mod; if ((ll)i * i != n) res = ((ll)res + (ll)qmi(n, n / i) * phi(i) % mod) % mod; } } res = (ll)res * qmi(n, mod - 2) % mod; printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } 六.生成函数 又叫母函数。\n生成函数可以将乘法原理与多项式乘法相联系起来。\n1.常用无穷级数 对于$x∈(-1,1)，$$A(x)=x_0 + x_1+x_2+\u0026hellip;+x_k+\u0026hellip; \\ = \\frac{1}{1-x}$ 。\n推广： 对于$x∈(-1,1)，$$A(x)=\\sum_{i = 0}^{∞}{C_{i+n-1}^{n-1}x^i}\\ = \\frac{1}{(1-x)^n}$ 。\n2.例子 1，2，6三个重量的砝码有无穷多个，用这些砝码组合称出重量为n的方案数: $A_1(x)=1+x^1+x^2+\u0026hellip;$ $A_2(x)=1+x^2+x^4+\u0026hellip;$ $A_6(x)=1+x^6+x^{12}+\u0026hellip;$ 答案多项式就为$A(x)=A_1(x)*A_2(x)*A_3(x)$\n","permalink":"https://liuyilong.com/p/tech/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","summary":"常用或不常用的组合数学概念与公式","title":"组合数学"},{"content":"二项式反演 演绎推理是我们在数学中经常遇到的一些方法。对于数列来说，通过原数列计算出新的数列叫作演绎，而通过计算出的数列反推出原数列则被称为反演。\n形式化地，如果原数列为 $\\{fn\\}$，新数列是 $\\{gn\\}$ ，且满足： $$ g_n=\\sum_{i=0}^na_{n,i}f_i $$ 反演就是我们希望通过 $\\{gn\\}$ 得到 $\\{fn\\}$： $$ f_n=\\sum_{i=0}^nb_{n,i}g_i $$ 结合一下就是： $$ g_n=\\sum_{i=0}^na_{n,i}f_i\\Leftrightarrow f_n=\\sum_{i=0}^nb_{n,i}g_i $$ 数列反演有许许多多种不同的类型，就例如莫比乌斯反演，二项式反演等等。其实，我们发现反演其实就是在解方程，一些方程组有算法上固定的、特殊的解，我们对于这些特殊的算法冠以具体的名字，就例如二项式反演。\n反演公式 二项式反演的内容是： $$ g_n=\\sum_{i=0}^n(-1)^iC_n^if_i\\Rightarrow f_n=\\sum_{i=0}^n(-1)^iC_n^ig_i $$ 这个式子高度对称，它还有一个等价形式是我们所常用的： $$ g_n=\\sum_{i=0}^nC_n^if_i\\Rightarrow f_n=\\sum_{i=0}^n(-1)^{n-i}C_n^ig_i $$ 其实这里应该是双箭头，但是在这里右式是反演，左式则是演绎，故我们向右推出。先来证明这个反演公式，然后介绍它的应用。\n代数证明 我们从等号右边开始，将 $g_n=\\sum_{i=0}^nC_n^if_i$ 带入: $$ \\begin{aligned} \\sum_{i=0}^n(-1)^{n-i}C_n^ig_i \u0026amp;=\\sum_{i=0}^n(-1)^{n-i}C_n^i\\sum_{j=0}^iC_i^jf_j\\\\ \u0026amp;=\\sum_{i=0}^n\\sum_{j=0}^i(-1)^{n-i}C_n^iC_i^jf_j \\end{aligned} $$ 我们尝试交换求和顺序。首先容易得到: $$ C_n^iC_i^j=C_n^jC_{n-j}^{i-j}=C_n^jC_{n-j}^{n-i} $$ 带入进去得到: $$ \\begin{aligned} \\sum_{i=0}^n(-1)^{n-i}C_n^ig_i \u0026amp;=\\sum_{i=0}^n\\sum_{j=0}^i(-1)^{n-i}C_n^jC_{n-j}^{n-i}f_j\\\\ \u0026amp;=\\sum_{j=0}^n\\sum_{i=j}^nC_n^jf_j(-1)^{n-i}C_{n-j}^{n-i} \\end{aligned} $$ 把 $C_n^jf_j$ 提取出来得到：\n$$ \\sum_{i=0}^n(-1)^{n-i}C_n^ig_i=\\sum_{j=0}^nC_n^jf_j\\sum_{i=j}^n(-1)^{n-i}C_{n-j}^{n-i} $$ 对于右面的：$\\sum_{i=j}^n(-1)^{n-i}C_{n-j}^{n-i}=\\sum_{k=0}^{n-j}(-1)^kC_{n-j}^k$\n当 $n-j\\neq 0$ 时，$\\sum_{k=0}^{n-j}(-1)^kC_{n-j}^k=(1-1)^{n-j}=0$ 当 $n-j=0$ 时，$j=n$，则 $\\sum_{k=0}^{n-j}(-1)^kC_{n-j}^k=(-1)^0C_0^0=1$ 所以只有当 $j=n$ 时 $\\sum_{i=0}^n(-1)^{n-i}C_n^ig_i\\neq0$，于是 $$ \\begin{aligned} \\sum_{i=0}^n(-1)^{n-i}C_n^ig_i \u0026amp;=C_n^nf_n(-1)^0C_0^0\\\\ \u0026amp;=f_n \\end{aligned} $$ 证毕。\n","permalink":"https://liuyilong.com/p/tech/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","summary":"算法竞赛多项式相关知识点","title":"二项式反演"},{"content":"组合定义：$L=D-W$\n标准化的：$L_{sym}=D^{-\\frac{1}{2}}LD^{-\\frac{1}{2}}=I-D^{-\\frac{1}{2}}WD^{-\\frac{1}{2}}$\n性质：\n因为 $L$ （或 $L_{sym}$） 是实对称矩阵，所以 $L$ （或 $L_{sym}$）可以正交相似对角化 $L($或 $L_{sym})=U\\Lambda U^T$\n$L$ 与 $L_{sym}$ 是半正定矩阵\n证明：\n构造一个矩阵 $G_{(i,j)}=\\begin{bmatrix} {{\\ddots}}\u0026amp;{}\u0026amp;{}\u0026amp;{}\u0026amp;{}\\\\ {}\u0026amp;{g_{ii=}w_{ij}}\u0026amp;{\\cdots}\u0026amp;{g_{ij}=-w_{ij}}\u0026amp;{}\\\\ {}\u0026amp;{\\vdots}\u0026amp;{\\ddots}\u0026amp;{\\vdots}\u0026amp;{}\\\\ {}\u0026amp;{g_{ji}=-w_{ij}}\u0026amp;{\\cdots}\u0026amp;{g_{jj}=w_{ij}}\u0026amp;{}\\\\ {}\u0026amp;{}\u0026amp;{}\u0026amp;{}\u0026amp;{{\\ddots}}\\\\ \\end{bmatrix}$ ，其中在第 $i$ 行第 $i$ 列与第 $j$ 行第 $j$ 列处是$w_{ij}$（权重矩阵 $W$ 的第 $i,j$ 处的值），其余位置都是 0 。那么有 $L=\\sum_{(i,j)\\in E,i\u0026lt;j}\\ G_{(i,j)}$ ，其中 $E$ 是边集，对于任意的向 $n$ 维向量 $x$ 有（下面其实就是 $G_{(i,j)}$ 的二次型）： $$ \\begin{aligned} x^TG_{(i,j)}x\u0026amp;=x^T\\begin{bmatrix} {{\\vdots}}\\\\ {w_{ij}(x_i-x_j)}\\\\ {{\\vdots}}\\\\ {w_{ij}(x_j-x_i)}\\\\ {{\\vdots}}\\\\ \\end{bmatrix}\\\\ \u0026amp;=w_{ij}x_i(x_i-x_j)+w_{ij}(x_j-x_i)\\\\ \u0026amp;=w_{ij}(x_i-x_j)^2 \\end{aligned} $$ 所以： $$ \\begin{aligned} x^TLx\u0026amp;=x^T(\\sum_{(i,j)\\in E,i\u0026lt;j}G_{(i,j)}\\ ) x\\\\ \u0026amp;=\\sum_{(i,j)\\in E,i\u0026lt;j}x^TG_{(i,j)}x\\\\ \u0026amp;=\\sum_{(i,j)\\in E,i\u0026lt;j}w_{ij}(x_i-x_j)^2 \\geq0 \\end{aligned} $$ 同样的： $$ \\begin{aligned} x^TL_{sym}x \u0026amp;=x^T(D^{-\\frac{1}{2}}LD^{-\\frac{1}{2}})x\\\\ \u0026amp;=(x^TD^{-\\frac{1}{2}})L(D^{-\\frac{1}{2}}x)\\\\ \u0026amp;=\\sum_{(i,j)\\in E,i\u0026lt;j}w_{ij}(\\frac{x_i}{\\sqrt d_i}-\\frac{x_j}{\\sqrt d_j})^2\\ \\geq0 \\end{aligned} $$\n即 $L/L_{sym}$ 的二次型是非负数，所以它们是半正定的。\n从实际意义出发，$L/L_{sym}$ 的二次型也因此称为对于信号 $x$ 的总变分，用以描述图的平滑度。\n$L$ 与 $L_{sym}$ 特征值非负且 $L_{sym}$ 的特征值小于等于2\n首先了解一下瑞利商：$R(A,x)=\\frac{x^TAx}{x^Tx}$，其中 $A$ 是方阵，$x$ 是非零向量。若 $x$ 是 $A$ 的一个特征向量，那么瑞利商就是其对应的特征值。\n因为瑞利商的分母为正， $L$ 与 $L_{sym}$ 半正定，所以分子是非负数，所以它们的特征值都是非负数。\n构造矩阵 $G_{(i,j)}^{pos}=\\begin{bmatrix} {{\\ddots}}\u0026amp;{}\u0026amp;{}\u0026amp;{}\u0026amp;{}\\\\ {}\u0026amp;{g_{ii=}w_{ij}}\u0026amp;{\\cdots}\u0026amp;{g_{ij}=w_{ij}}\u0026amp;{}\\\\ {}\u0026amp;{\\vdots}\u0026amp;{\\ddots}\u0026amp;{\\vdots}\u0026amp;{}\\\\ {}\u0026amp;{g_{ji}=w_{ij}}\u0026amp;{\\cdots}\u0026amp;{g_{jj}=w_{ij}}\u0026amp;{}\\\\ {}\u0026amp;{}\u0026amp;{}\u0026amp;{}\u0026amp;{{\\ddots}}\\\\ \\end{bmatrix}$，那么 $x^TG_{(i,j)}^{pos}x=w_{ij}(x_i+x_j)^2$。\n定义 $L^{pos}=D+W=\\sum_{(i,j)\\in E,i\u0026lt;j}\\ G_{(i,j)}^{pos}$，则 $x^TL^{pos}x=\\sum w_{ij}(x_i-x_j)^2 \\geq0$\n定义 $L_{sym}^{pos}=D^{-\\frac{1}{2}}L^{pos}D^{-\\frac{1}{2}}=I+D^{-\\frac{1}{2}}WD^{-\\frac{1}{2}}$，则 $x^TL_{sym}^{pos}x=\\sum w_{ij}(\\frac{x_i}{\\sqrt d_i}-\\frac{x_j}{\\sqrt d_j})^2\\ \\geq0$\n所以有： $$ \\begin{aligned}x^TL_{sym}^{pos}x\u0026amp;\\geq0\\\\ x^T(I+D^{-\\frac{1}{2}}WD^{-\\frac{1}{2}})x\u0026amp;\\geq0\\\\ x^Tx\u0026amp;\\geq-x^TD^{-\\frac{1}{2}}WD^{-\\frac{1}{2}}x\\\\ 2x^Tx\u0026amp;\\geq x^Tx-x^TD^{-\\frac{1}{2}}WD^{-\\frac{1}{2}}x\\\\ 2x^Tx\u0026amp;\\geq x^T(I-D^{-\\frac{1}{2}}WD^{-\\frac{1}{2}})x\\\\ 2x^Tx\u0026amp;\\geq x^TL_{sym}x\\\\ 2\u0026amp;\\geq \\frac{x^TL_{sym}x}{x^Tx}\\\\ \\end{aligned} $$ 证毕。\n图傅里叶变换\n$\\hat{x}=U^Tx$ 因为傅里叶变换就是信号函数与对应傅里叶基做点积，而图的傅里叶基就是 $U$ 的所有列向量。为什么？类比得到的。\n参考：\n图卷积神经网络（GCN）的数学原理详解——谱图理论和傅立叶变换初探 https://www.bilibili.com/video/BV1Vw411R7Fj?p=2\u0026amp;vd_source=6d147d62785fc8372968b3a6b3a0011d\n","permalink":"https://liuyilong.com/p/tech/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5/","summary":"谱图理论中拉普拉斯矩阵学习笔记","title":"拉普拉斯矩阵"},{"content":"min-max容斥 min-max容斥本身是集合有关的定理，但是一般会用于解决概率和期望相关的问题。\n我们知道 线性运算的期望 等于 期望的线性运算，即 $E(aX+bY)=aE(X)+bE(Y)$。\n但是对于最大值和最小值则没有这种性质，即 $E(max(X,Y))\\neq max(E(X),E(Y))$，$min$同理。\n例子：\n抛硬币，$X=Y=\\begin{cases}0\u0026amp;(50\\%) \\\\ 1\u0026amp;(50\\%)\\end{cases} $ ，则 $E(X)=E(Y)=0.5$\n那么 $max(X,Y)=\\left \\{ \\begin{aligned} \u0026amp;max(0,0)\u0026amp;(25\\%)\\\\ \u0026amp;max(0,1)\u0026amp;(25\\%)\\\\ \u0026amp;max(1,0)\u0026amp;(25\\%)\\\\ \u0026amp;max(1,1)\u0026amp;(25\\%) \\end{aligned} \\right.$ ，则 $E(max(X,Y))=0.75$\n然而 $max(E(X),E(Y))=0.5$，所以这个对于 $max$ 和 $min$ 的期望是不能直接这样运算的。\n定理 给定集合 $S$，设 $max(S)$ 为 $S$ 中最大值，$min(S)$ 为 $S$ 中的最小值，则有： $$ max(S)=\\sum_{T\\subseteq S}(-1)^{|T|-1}min(T)\\\\\\ min(S)=\\sum_{T\\subseteq S}(-1)^{|T|-1}max(T) $$ 并且由于期望线性组合的性质，这个式子对于概率期望也是正确的，即： $$ E(max(S))=\\sum_{T\\subseteq S}(-1)^{|T|-1}E(min(T)) $$\n证明 证明第一个式子，首先考虑构造一个容斥系数 $f(x)$ 使得： $$ max(S)=\\sum_{T\\subseteq S}f(|T|)min(T) $$ 然后考虑第 $x+1$ 大的元素会被统计的贡献，即枚举有哪多少个集合的最小元素为第 $x+1$ 大，则： $$ [x==0]=\\sum_{i=0}^xC_x^if(i+1) $$ 二项式反演得到： $$ \\begin{aligned} f(x+1) \u0026amp;=\\sum_{i=0}^x(-1)^{x-i}[i==0]\\\\ \u0026amp;=(-1)^x \\end{aligned} $$ 所以： $$ f(x)=(-1)^{x-1} $$ 综上可得： $$ \\begin{aligned} max(S) \u0026amp;=\\sum_{T\\subseteq S}f(|T|)min(T)\\\\ \u0026amp;=\\sum_{T\\subseteq S}(-1)^{|T|-1}min(T) \\end{aligned} $$ 证毕。\n","permalink":"https://liuyilong.com/p/tech/min-max%E5%AE%B9%E6%96%A5/","summary":"算法竞赛概率相关知识点min-max容斥","title":"Min-Max容斥"},{"content":"这是一个使用hugo搭建的静态博客，主题是PaperMod，使用github actions自动部署在github pages上。\n先记录一下遇到的第一个问题吧，hugo部署到git pages后自定义域名就失效了，原因是部署后CNAME文件就没了，要在.github/workflows/deploy.yml下添加cname: yourdomain.com，或者直接在static文件夹下新建一个CNAME文件。\n测试标题\nH1一级标题 H2二级标题 H3三级标题 H4四级标题 H5五级标题 H6六级标题 测试一下行间公式 $$ E=mc^2 $$\n测试一下行内$a^2=b^2+c^2$公式\n测试一下代码块\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { printf(\u0026#34;hello world\u0026#34;); return 0; } 测试一下图片\n","permalink":"https://liuyilong.com/p/tech/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/","summary":"搭建HUGO博客遇到的问题以及功能测试","title":"搭建HUGO博客"}]